
SELECT * FROM DUAL

SELECT SYSDATE FROM DUAL


-- plsql (programming language + SQL) -- this program runs in the database world
-- plsql (database programming language)
-- structure


DECLARE
    
BEGIN

EXCEPTION

END;

-- Program (Variables, logic, error handling)
-- Program (Number, Char, Varchar, Date, Boolean --- If then else, loops -- Exception handling)
-- Program (Exception,PLSQL Tables -- array -- special data types)

DECLARE
    -- Optional    
BEGIN
    -- Mandotory
EXCEPTION
    -- Optional
END;


begin
   dbms_output.put_line ('Hello world');
end;

set serveroutput on


DECLARE
    VAR_NUMBER1 NUMBER(4);
    VAR_NUMBER2 NUMBER(4);
    VAR_NUMBER3 NUMBER(4);
BEGIN
    VAR_NUMBER1 := &NUMBER1;
    VAR_NUMBER2 := &NUMBER2;
    VAR_NUMBER3 := &NUMBER3;
    
    IF VAR_NUMBER1 > VAR_NUMBER2 THEN
        IF VAR_NUMBER1 > VAR_NUMBER3 THEN
            DBMS_OUTPUT.PUT_LINE (VAR_NUMBER1 || ' IS THE GREATEST OF ALL THREE');
        END IF;
    END IF;
    
    IF VAR_NUMBER2 > VAR_NUMBER1 THEN
        IF VAR_NUMBER2 > VAR_NUMBER3 THEN
            DBMS_OUTPUT.PUT_LINE (VAR_NUMBER2 || ' IS THE GREATES OF ALL THREE');
        END IF;
    END IF;
    
    IF VAR_NUMBER3 > VAR_NUMBER1 THEN
        IF VAR_NUMBER3 > VAR_NUMBER2 THEN
            DBMS_OUTPUT.PUT_LINE (VAR_NUMBER3 || ' IS THE GREATES OF ALL THREE');
        END IF;
    END IF;
END;



SYNTAX OF IF

IF <CONDITION> THEN

END IF;

IF <CONDITION> THEN

ELSE

END IF;

IF <CONDITION> THEN

ELSIF <CONDITION> THEN

ELSIF <CONDITION> THEN

ELSE

END IF;


DECLARE
    VAR_FIRST_NUMBER NUMBER(4);
    VAR_LAST_NUMBER NUMBER(4);
BEGIN
    VAR_FIRST_NUMBER := 15;
    VAR_LAST_NUMBER := 20;
    
    FOR I IN VAR_FIRST_NUMBER..VAR_LAST_NUMBER LOOP
        DBMS_OUTPUT.PUT_LINE (I);
    END LOOP;
  
END;



DECLARE
    VAR_FIRST_NUMBER NUMBER(4);
    VAR_LAST_NUMBER NUMBER(4);
    VAR_I NUMBER(4);
BEGIN
    VAR_FIRST_NUMBER := 15;
    VAR_LAST_NUMBER := 20;
    VAR_I := VAR_FIRST_NUMBER;
    LOOP
        EXIT WHEN VAR_I > VAR_LAST_NUMBER;
        DBMS_OUTPUT.PUT_LINE (VAR_I);
        VAR_I := VAR_I + 1;
    END LOOP;
END;

SELECT SYSDATE1 FROM DUAL

--IF ANY INPUT WE GET, IF ITS NEGATIVE NUMBER THEN RAISE AN ERROR
DECLARE
    VAR_FIRST_NUMBER NUMBER(4);
    VAR_LAST_NUMBER NUMBER(4);
    VAR_I NUMBER(4);
BEGIN
    VAR_FIRST_NUMBER := &FIRST_NUMBER;
    VAR_LAST_NUMBER := &LAST_NUMBER;
    
    IF VAR_FIRST_NUMBER < 0 OR VAR_LAST_NUMBER < 0 THEN
        RAISE_APPLICATION_ERROR (-20000, 'WE CANNOT HAVE A NUMBER < 0 AS THE INPUT'); -- IT STOPS YOUR PROGRAM. TELL ME THE CODE AND REASON -- 20000 TO -20999
    END IF;
    
    VAR_I := VAR_FIRST_NUMBER;
    LOOP
        EXIT WHEN VAR_I > VAR_LAST_NUMBER;
        DBMS_OUTPUT.PUT_LINE (VAR_I);
        VAR_I := VAR_I + 1;
    END LOOP;
END;

--SELECT  * FROM EMPLOYEE
-- TAKE EMPLOYEE ID AS THE INPUT AND GIVE EMPNAME AS THE OUT PUT
DESC EMPLOYEE

DECLARE 
    VAR_EMPNO NUMBER(5);
    VAR_EMPNAME EMPLOYEE.EMP_NAME%TYPE; -- INHERITING THE DATA TYPE OF A COLUMN TO A VARIABLE
    VAR_DEPT_ID NUMBER(3);
BEGIN
    VAR_EMPNO := &EMPID;
    -- EMBEDDED SELECT STATEMENT
    SELECT
        EMP_NAME, DEPT_ID INTO VAR_EMPNAME, VAR_DEPT_ID
    FROM
        EMPLOYEE
    WHERE EMP_ID = VAR_EMPNO;
    -- PRINTING THE EMP NAME    
    DBMS_OUTPUT.PUT_LINE ('EMPLOYEE  ' || VAR_EMPNAME || ' IS WORKING IN THE DEPT ' || VAR_DEPT_ID);
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE ('NO SUCH EMPLOYEE EXISTS IN EMPLOYEE TABLE WITH AN EMP_ID OF ' || VAR_EMPNO);
END;

--NO_DATA_FOUND -- PRE DEFINED EXCEPTION WHICH YOU CAN USE IN YOUR PROGRAM (SYSTEM DEFINED)

--SELECT * fROM DEPT

--TAKE DEPT_ID & DEPT_NAME AS THE INPUT
-- IF THE DEPT_NAME OF THE DEPT_ID IS DIFFERENT THAN WHAT EXISTS, THEN DO AN UPDATE.
-- IF THE DEPT_ID DOES NOT EXISTS IN THE DEPT TABLE THEN DO AN INSERT. INSERT UNKNOWN AS THE VALUE FOR DEPT_LOC FOR THAT DEPT_ID
30 SUPPORT --> WHAT SHOULD HAPPEN -- ??? (NOTHING)
30 CUS SUPPORT --> wHAT SHOUDL HAPPEN -- (UPDATE)
60 DISTRIBUTION --> WHAT SHOULD HAPPEN -- (INSERT -- 60, DISTRIBUTION, UNKNOWN)

DECLARE
    VAR_DEPT_ID DEPT.DEPT_ID%TYPE;
    VAR_DEPT_NAME_IP DEPT.DEPT_NAME%TYPE;
    VAR_DEPT_NAME DEPT.DEPT_NAME%TYPE;
BEGIN
    VAR_DEPT_ID := & DEPT_ID;
    VAR_DEPT_NAME_IP := & DEPT_NAME_IP;
    -- GETTING DEPT_NAME FROM THE TABLE
    SELECT DEPT_NAME INTO VAR_DEPT_NAME
    FROM DEPT
    WHERE DEPT_ID = VAR_DEPT_ID;
    -- SELECT GIVES ME DATA THE CONTROL GOES TO NEXT LINE
    IF VAR_DEPT_NAME <> VAR_DEPT_NAME_IP THEN
        UPDATE DEPT SET DEPT_NAME = VAR_DEPT_NAME_IP
        WHERE DEPT_ID = VAR_DEPT_ID;
        COMMIT;
    END IF;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        INSERT INTO DEPT VALUES (VAR_DEPT_ID, VAR_DEPT_NAME_IP, 'UNKNOWN');
        COMMIT;
END;


SELECT * FROM DEPT




---PLSQL -- ITS USED FOR DATA PROCESSING ACTIVITIES
-- LOT OF DATA PROCESSING IN etl (TRANSFORMATION)
-- IF YOU CANNOT A LOGIC IN sql, THEN TAKE ADVANTAGE OF plsql TO IMPLEMENT THE SAME






SELECT EMP_ID, EMP_NAME
FROM EMPLOYEE
WHERE EMP_ID = 101



